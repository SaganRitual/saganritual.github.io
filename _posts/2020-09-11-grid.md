---
layout: post
title: Grid Your Lines
---
## A Basic Grid Object
What's the point of formalizing something so basic? Judicious laziness, as always. Anything that makes for less typing and/or less thinking is a bonus in my world. Here's a grid that does both nicely.

### The Overload2D protocol
`Overload2D` is a set of arithmetic operations on ordered pairs, for example, `CGPoint`. With `Overload2D` you can add and subtract a `CGPoint`to another (or `CGSize` or `CGVector`, or indeed, any ordered pair that conforms to the `Overload2D` protocol). You can multiply and divide by scalars or by ordered pairs. There are various utility functions available, such as `hypoteneuse` and `area` for size-like pairs, and (r, Î¸) representation for vector- and point-like pairs.

### Indexed addressing on the grid
In the "Snake" AI genetic algorithm apps I've studied, the snake can "sense" only one grid cell away, that is, only the cells adjacent to the snake's head are visible to the snake. In _Arkonia_, my creatures' sensory ranges vary based on genetics and health. The `Indexer` allows you to scan cells as though they're in a linear array, eliminating all that nasty calculating cell locations.

### Asteroidization
You old people out there might recall one of the earliest coin-operated video games, called "Asteroids". You may recall that when any object reached one edge of the screen, it would disappear and reappear on the opposite edge, as opposed to simply crashing into the wall. The grid I'm demonstrating here makes that kind of "warp-jump" easy.

### Important Concepts

#### `KGPoint`, `KGSize`, `KGVector`
Basic ordered pairs: (x, y), (width, height), and (dx, dy), respectively. Analagous to Swift's `CGPoint/Size/Vector`, but with `Int` rather than CGFloat as the data type for the pair elements. This results in each cell having a unique, whole-number address that will never be affected by rounding when used in calculations.

#### The indexer
The grid can be addressed in three ways:

* By referring to a `KGPoint`
* By a scalar offset--an absolute index--on the grid
* By an index relative to some point on the grid

While a `KGPoint` is simply an (x, y) pair, an absolute index is basically an opaque type. Don't try to do calculations with it; treat it as though it were a cell ID that is subject to change.

#### Relative indexing and sense rings

<img src="/assets/img/grid.png" width="480px" height="300px" style="float: right; margin-left: 15px"/>
The third method of accessing cells is via relative index, which is a simple `Int` offset that presents the "rings" of cells around a specified center cell as a continuous array. The diagram on the right shows the characteristics of a local index. Notice that index zero is the center of the grid, and the positive indices spiral outward in a roughly anti-clockwise fashion. The "rings" around the center, in yellow, pink, and purple, can be thought of as sensory rings, each ring extending the sensory range of the gremlin sitting at cell 0.
<img src="/assets/img/asteroiding.png" width="480px" height="300px" style="float: left; margin-right: 15px; margin-top: 25px"/>

#### Asteroidization

When addressing cells using a relative index, the grid provides two key positions:
* The _real_ grid position, representing the wrap-around point where a gremlin would appear if Asteroids-style wrapping is desired
* The _virtual_ grid position, representing a point off the grid where the gremlin would go if it were to continue beyond the boundary without wrapping. 

The primary purpose of this extra position is to allow the game to determine the distance the gremlin will be moving. In the diagram on the left, consider the purple cell to be where the gremlin is currently sitting. When requesting cells by relative index, the app will get back the _real_ positions as shown here in yellow, so it will know where to position the gremlin, and the _virtual_ positions as shown in gray, so it will know the direction and distance the gremlin moved.

Of course in most of the Snake AI implementations I've seen, the edges are walls; there's no warping across space, the snake just dies under the cruel talons of natural selection. Sadists and snake-haters need not worry; there is an `isOnGrid()` function for them.

### The API

* Cell Addressing Functions
 * `cellAt(_ absoluteIndex: Int) -> GridCell`
 * `cellAt(_ position: KGPoint) -> GridCell`
 * `cellAt(_ localIndex: Int, from center: KGPoint) -> GridCell`
